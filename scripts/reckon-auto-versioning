#!/bin/bash

# Obtém a mensagem do último commit
git fetch origin

# Verifica se existem tags
LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "no-tag")

if [ "$LAST_TAG" = "no-tag" ]; then
  echo "No tags found. Using fallback."
  LAST_COMMIT_MESSAGE=$(git log --pretty=format:"%s")
else
  LAST_COMMIT_MESSAGE=$(git log ${LAST_TAG}..HEAD --pretty=format:"%s")
fi


echo $LAST_COMMIT_MESSAGE

# Define o escopo com base na mensagem do commit'
if echo "$LAST_COMMIT_MESSAGE" | grep -q "BREAKING CHANGE"; then
  SCOPE=major
elif echo "$LAST_COMMIT_MESSAGE" | grep -E -q '^.*!'; then
  SCOPE=major
elif echo "$LAST_COMMIT_MESSAGE" | grep -E -q '^(feat)'; then
  SCOPE=minor
elif echo "$LAST_COMMIT_MESSAGE" | grep -E -q '^(fix)'; then
  SCOPE=patch
else
  SCOPE=patch
fi

# Exibe o escopo detectado (para depuração)
echo "Determined scope: $SCOPE"

# Exporta o escopo para ser usado no pipeline
echo "SCOPE=$SCOPE" >> $GITHUB_ENV

